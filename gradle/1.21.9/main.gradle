println("Java: " + System.getProperty("java.version") + " JVM: " + System.getProperty("java.vm.version") + "(" + System.getProperty("java.vendor") + ") Arch: " + System.getProperty("os.arch"))

allprojects {
    apply plugin: "java"
    apply plugin: "java-library"
    apply plugin: "architectury-plugin"
    apply plugin: "maven-publish"
    apply plugin: "signing"
    apply plugin: "idea"

    base.archivesName = "${modName.replaceAll("[^a-zA-Z]", "")}"
    version = "v${modVersion}+mc${libs.versions.minecraft.get()}-${project.name}"
    group = modMavenGroup

    repositories {
        mavenCentral()
        mavenLocal()
        maven {
            name = "Fuzs Mod Resources"
            url = "https://raw.githubusercontent.com/Fuzss/modresources/main/maven/"
        }
        maven {
            name = "Parchment"
            url = "https://maven.parchmentmc.org"
        }
        maven {
            name = "Jared"
            url = "https://maven.blamejared.com/"
        }
        maven {
            name = "Jitpack"
            url = "https://jitpack.io"
        }
        maven {
            name = "Shedaniel"
            url = "https://maven.shedaniel.me/"
        }
        maven {
            name = "Wisp Forest"
            url "https://maven.wispforest.io/releases/"
        }
        maven {
            name = "Su5eD"
            url "https://maven.su5ed.dev/releases/"
        }
        maven {
            name = "Minecraft Forge"
            url "https://maven.minecraftforge.net/"
        }
        maven {
            name = "Terraformers"
            url = "https://maven.terraformersmc.com/"
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "AppleSkin"
                    url = uri("https://maven.ryanliptak.com/")
                }
            }
            filter {
                includeGroup("squeek.appleskin")
            }
        }
        exclusiveContent {
            forRepository {
                maven {
                    name "KosmX"
                    url "https://maven.kosmx.dev/"
                }
            }
            filter {
                includeGroup("dev.kosmx.player-anim")
            }
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "GeckoLib"
                    url = "https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/"
                }
            }
            filter {
                includeGroup("software.bernie.geckolib")
            }
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "SmartBrainLib"
                    url = "https://dl.cloudsmith.io/public/tslat/sbl/maven/"
                }
            }
            filter {
                includeGroup("net.tslat.smartbrainlib")
            }
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "CurseForge"
                    url = "https://cursemaven.com/"
                }
            }
            filter {
                includeGroup "curse.maven"
            }
        }
        exclusiveContent {
            forRepository {
                maven {
                    name = "Modrinth"
                    url = "https://api.modrinth.com/maven/"
                }
            }
            filter {
                includeGroup "maven.modrinth"
            }
        }
    }

    tasks.withType(JavaCompile).configureEach {
        // ensure that the encoding is set to UTF-8, no matter what the system default is
        // this fixes some edge cases with special characters not displaying correctly
        // see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
        // If Javadoc is generated, this must be specified in that task too.
        options.encoding = "UTF-8"
        options.release = libs.versions.java.get() as Integer
        options.warnings = false
    }

    java {
        toolchain.languageVersion = JavaLanguageVersion.of(libs.versions.java.get())
        withSourcesJar()
        withJavadocJar()
    }

    // silence missing javadoc comments, we just don't care
    javadoc.options.addStringOption("Xdoclint:none", "-quiet")

    tasks.withType(Jar).configureEach {
        duplicatesStrategy DuplicatesStrategy.EXCLUDE

        from rootProject.file("../LICENSE.md")
        from rootProject.file("../LICENSE-ASSETS.md")
        from rootProject.file("../LICENSE-FORGE.md")
        from rootProject.file("../LICENSE-NIGHT-CONFIG.md")
        from rootProject.file("../LICENSING.md")
        from rootProject.file("CHANGELOG.md")

        manifest {
            attributes([
                    "Specification-Title"           : modName,
                    "Specification-Version"         : modVersion,
                    "Specification-Vendor"          : modAuthor,
                    "Implementation-Title"          : modName,
                    "Implementation-Version"        : modVersion,
                    "Implementation-Vendor"         : modAuthor,
                    "Implementation-Timestamp"      : new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                    "Implementation-Timestamp-Milli": System.currentTimeMillis(),
                    "Implementation-URL"            : modSourceUrl,
                    "Built-On-Java"                 : "${System.getProperty("java.vm.version")} (${System.getProperty("java.vm.vendor")})",
                    "Built-On-Minecraft"            : libs.versions.game.get()
            ])
        }

        group "jar"
    }

    tasks.withType(GenerateModuleMetadata) {
        // Disables Gradle's custom module metadata from being published to maven. The
        // metadata includes mapped dependencies which are not reasonably consumable by
        // other mod developers.
        enabled = false
    }

    // IDEA no longer automatically downloads sources / javadoc jars for dependencies,
    // so we need to explicitly enable the behavior.
    idea {
        module {
            downloadSources = true
            downloadJavadoc = true
        }
    }
}

subprojects {
    apply plugin: "dev.architectury.loom"
    apply plugin: "me.modmuss50.mod-publish-plugin"

    loom {
        silentMojangMappingsLicense()

        mixin {
            useLegacyMixinAp = true
            defaultRefmapName = "${modId}.${project.name.toLowerCase()}.refmap.json"
        }
    }

    dependencies {
        minecraft "com.mojang:minecraft:${libs.versions.game.get()}"
        mappings loom.layered() {
            officialMojangMappings {
                setNameSyntheticMembers(true)
            }
            parchment("org.parchmentmc.data:parchment-${libs.versions.parchment.minecraft.get()}:${libs.versions.parchment.version.get()}@zip")
        }
    }

    ext.incrementPatchVersion = { String version ->
        String[] parts = version.split("\\.")
        if (parts.length == 2) {
            parts = [parts[0], parts[1], "0"] as String[]
        } else if (parts.length < 2) {
            throw new IllegalArgumentException("Version must have at least MAJOR.MINOR")
        }

        int patch = parts[2].toInteger() + 1
        parts[2] = Integer.toString(patch)
        return parts.join(".")
    }

    processResources {
        duplicatesStrategy DuplicatesStrategy.EXCLUDE

        from(project(":Common").sourceSets.main.resources) {
            exclude "${modId}.common.mixins.json", "common.mixins.json"
        }

        from(project(":Common").file("src/generated/resources")) {
            exclude ".cache/"
        }

        var fileNames = [
                "^common.mixins.json\$": "${modId}.common.mixins.json",
                "^fabric.mixins.json\$": "${modId}.fabric.mixins.json",
                "^neoforge.mixins.json\$": "${modId}.neoforge.mixins.json",
                "^forge.mixins.json\$": "${modId}.forge.mixins.json"
        ]

        fileNames.forEach {from, to -> rename from, to }

        var resourceProperties = [
                "modId": modId,
                "modName": modName,
                "modVersion": modVersion,
                "modDescription": modDescription,
                "modGroup": project.group,
                "modPageUrl": modSourceUrl,
                "modIssueUrl": modIssueUrl,
                "modUpdateUrl": modUpdateUrl,
                "modAuthor": modAuthor,
                "modLicense": modLicense,
                "minFabricVersion": libs.versions.hasProperty("fabricloader") && libs.versions.fabricloader.hasProperty("min") ? libs.versions.fabricloader.min.get() : "1",
                "minFabricApiVersion": libs.versions.hasProperty("fabricapi") && libs.versions.fabricapi.hasProperty("min") ? libs.versions.fabricapi.min.get() : "1",
                "minForgeFMLVersion": "1",
                "minForgeVersion": libs.versions.hasProperty("minecraftforge") && libs.versions.minecraftforge.hasProperty("min") ? libs.versions.minecraftforge.min.get() : "1",
                "minNeoForgeFMLVersion": "1",
                "minNeoForgeVersion": libs.versions.hasProperty("neoforge") && libs.versions.neoforge.hasProperty("min") ? libs.versions.neoforge.min.get() : "1",
                "minecraftVersion": libs.versions.minecraft.get(),
                "upcomingMinecraftVersion": incrementPatchVersion(libs.versions.minecraft.get()),
                "minPuzzlesVersion": libs.versions.hasProperty("puzzleslib") && libs.versions.puzzleslib.hasProperty("min") ? libs.versions.puzzleslib.min.get() : "1",
                "mainEntryPoint": "${project.group}.fabric.${base.archivesName.get()}Fabric",
                "clientEntryPoint": "${project.group}.fabric.client.${base.archivesName.get()}FabricClient",
                "modFabricEnvironment": modFabricEnvironment,
                "modForgeDisplayTest": modForgeDisplayTest
        ]

        inputs.properties resourceProperties

        var matchingFiles = [
                "fabric.mod.json",
                "META-INF/neoforge.mods.toml",
                "META-INF/mods.toml",
                modId + ".common.mixins.json",
                modId + ".fabric.mixins.json",
                modId + ".neoforge.mixins.json",
                modId + ".forge.mixins.json",
                "common.mixins.json",
                "fabric.mixins.json",
                "neoforge.mixins.json",
                "forge.mixins.json"
        ]

        filesMatching(matchingFiles) {
            expand resourceProperties + [project: project]
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                artifactId = "${modId}-${project.name.toLowerCase()}"
                version = modVersion

                from components.java
                setArtifacts([
                        tasks.named("remapJar").get(),
                        tasks.named("sourcesJar").get(),
                        tasks.named("javadocJar").get()
                ])

                pom {
                    name = "${modName} [${project.name}]"
                    description = "${modDescription}"
                    url = "${modSourceUrl}"

                    scm {
                        url = "${modSourceUrl}"
                        connection = "${modSourceUrl}".replace("https", "scm:git:git") + ".git"
                        developerConnection = "${modSourceUrl}".replace("https://github.com/", "scm:git:git@github.com:") + ".git"
                    }

                    issueManagement {
                        system = "github"
                        url = "${modIssueUrl}"
                    }

                    licenses {
                        license {
                            name = "${modLicense}"
                            url = "https://spdx.org/licenses/${modLicense}.html"
                        }
                    }

                    developers {
                        developer {
                            id = "${modAuthor}".toLowerCase()
                            name = "${modAuthor}"
                        }
                    }
                }
            }
        }
        repositories {
            maven {
                name = "FuzsModResources"
                url = uri(project.hasProperty("modResources") ?
                        "${project.findProperty("modResources")}/maven" :
                        System.getenv("local_maven"))
            }
        }
    }

    signing {
        sign publishing.publications.mavenJava
    }

    tasks.withType(Class.forName("me.modmuss50.mpp.PublishModTask", true, project.buildscript.classLoader)).configureEach {
        doFirst {
            if (!file("../CHANGELOG.md").text.contains("v${modVersion}-${libs.versions.minecraft.get()}")) {
                throw new IllegalStateException("Missing changelog version: v${modVersion}-${libs.versions.minecraft.get()}")
            }
        }
    }

    publishMods {
        def changelogFile = file("../CHANGELOG.md")
        if (!changelogFile.canRead()) {
            println("Publish Mods: ${new FileNotFoundException("Could not read changelog file")}")
            return
        }

        file = remapJar.archiveFile
        changelog = changelogFile.text
        type = STABLE
        version = modVersion
        displayName = "[${project.name.toUpperCase()}] [${libs.versions.minecraft.get()}] ${base.archivesName.get()} v${modVersion}"
        modLoaders.add(project.name.toLowerCase())
//        dryRun = true

        curseforge {
            accessToken = project.findProperty("curseApiToken") ?: ""
            projectId = projectCurseForgeId
            minecraftVersions.add(libs.versions.minecraft.get())
            var requiredDependencies = "dependenciesRequired${project.name}CurseForge"
            var embeddedDependencies = "dependenciesEmbedded${project.name}CurseForge"
            var optionalDependencies = "dependenciesOptional${project.name}CurseForge"
            if (project.hasProperty(requiredDependencies) || project.hasProperty(embeddedDependencies) || project.hasProperty(optionalDependencies)) {
                if (project.hasProperty(requiredDependencies)) {
                    (project.findProperty(requiredDependencies) as String).split(",").each {
                        requires it.trim()
                    }
                }
                if (project.hasProperty(embeddedDependencies)) {
                    (project.findProperty(embeddedDependencies) as String).split(",").each {
                        embeds it.trim()
                    }
                }
                if (project.hasProperty(optionalDependencies)) {
                    (project.findProperty(optionalDependencies) as String).split(",").each {
                        optional it.trim()
                    }
                }
            }
        }

        modrinth {
            accessToken = project.findProperty("modrinthPersonalAccessToken") ?: ""
            projectId = projectModrinthId
            minecraftVersions.add(libs.versions.minecraft.get())
            var requiredDependencies = "dependenciesRequired${project.name}Modrinth"
            var embeddedDependencies = "dependenciesEmbedded${project.name}Modrinth"
            var optionalDependencies = "dependenciesOptional${project.name}Modrinth"
            if (project.hasProperty(requiredDependencies) || project.hasProperty(embeddedDependencies) || project.hasProperty(optionalDependencies)) {
                if (project.hasProperty(requiredDependencies)) {
                    (project.findProperty(requiredDependencies) as String).split(",").each {
                        requires it.trim()
                    }
                }
                if (project.hasProperty(embeddedDependencies)) {
                    (project.findProperty(embeddedDependencies) as String).split(",").each {
                        embeds it.trim()
                    }
                }
                if (project.hasProperty(optionalDependencies)) {
                    (project.findProperty(optionalDependencies) as String).split(",").each {
                        optional it.trim()
                    }
                }
            }
        }

        github {
            accessToken = project.findProperty("githubReleaseToken") ?: ""
            repository = modSourceUrl.replace("https://github.com/", "")
            commitish = "main"
            tagName = "v${modVersion}+mc${libs.versions.minecraft.get()}/${project.name.toLowerCase()}"
            // only include the changelog for this release
            // the GitHub page display versions nicely, there is no need to attach the full changelog for every release
            changelog = "## [" + changelog.get().split("(?m)^## \\[", 3)[1].trim()
            additionalFiles.from(sourcesJar.archiveFile)
            additionalFiles.from(javadocJar.archiveFile)
        }
    }

    tasks.register("refreshUpdateJson") {
        onlyIf { project.hasProperty("modResources") }
        doLast {
            var updateFile = file(project.findProperty("modResources").concat(File.separator).concat("update").concat(File.separator).concat("${modId}").concat(".json"))
            var updateJson
            if (updateFile.exists() && updateFile.canRead()) {
                updateJson = new groovy.json.JsonSlurper().parseText(updateFile.text)
                updateJson["promos"]["${libs.versions.minecraft.get()}-latest"] = "${modVersion}"
                // alpha and beta releases will contain "a" or "b" char respectively, don"t update recommended for those
                if ("${modVersion}".matches("[^a-zA-Z]+")) {
                    updateJson["promos"]["${libs.versions.minecraft.get()}-recommended"] = "${modVersion}"
                }
            } else {
                var builder = new groovy.json.JsonBuilder()
                updateJson = builder {
                    homepage "${modSourceUrl}"
                    promos {
                        "${libs.versions.minecraft.get()}-latest" "${modVersion}"
                        // alpha and beta releases will contain "a" or "b" char respectively, don"t update recommended for those
                        if ("${modVersion}".matches("[^a-zA-Z]+")) {
                            "${libs.versions.minecraft.get()}-recommended" "${modVersion}"
                        }
                    }
                }
            }
            var output = new groovy.json.JsonOutput()
            updateFile.write(output.prettyPrint(output.toJson(updateJson)))
        }
    }

    tasks.register("copyJarToDir", Copy) {
        onlyIf { project.hasProperty("buildJarOutputDir") && project.hasProperty("uniqueBuildNumber") && project.findProperty("copyBuildJar").toBoolean() }
        from remapJar
        into project.findProperty("buildJarOutputDir")
        // add build number to be able to distinguish jars when testing thorough official launcher
        // build number is stored in global gradle.properties
        rename { fileName -> fileName.replace("v${modVersion}", "v${modVersion}.${uniqueBuildNumber}") }
    }

    tasks.register("incrementBuildNumber") {
        onlyIf { project.hasProperty("uniqueBuildNumber") }
        doLast {
            var propertiesName = "gradle.properties"
            // build number is stored in global gradle.properties
            var propertiesFile = new File(project.gradle.gradleUserHomeDir, propertiesName)
            if (!propertiesFile.canRead()) { throw new FileNotFoundException("Could not read file ".concat(propertiesName)) }
            var buildNumberMatcher = java.util.regex.Pattern.compile("uniqueBuildNumber=(\\d+)").matcher(propertiesFile.getText())
            buildNumberMatcher.find()
            var versionCode = Integer.parseInt(buildNumberMatcher.group(1))
            var propertiesContent = buildNumberMatcher.replaceAll("uniqueBuildNumber=" + ++versionCode)
            propertiesFile.write(propertiesContent)
        }
    }

    build.finalizedBy project.tasks.copyJarToDir, project.tasks.incrementBuildNumber
}

apply from: "https://raw.githubusercontent.com/Fuzss/modresources/main/gradle/${libs.versions.minecraft.get()}/tasks.gradle"
apply from: "https://raw.githubusercontent.com/Fuzss/modresources/main/gradle/${libs.versions.minecraft.get()}/discord.gradle"

architectury {
    minecraft = libs.versions.game.get()
}

def parseChangelogFields() {
    def changelog = file("CHANGELOG.md").text
    // Extract most recent section (everything until next "## " or EOF)
    def matcher = (changelog =~ /## \[.*?] - \d{4}-\d{2}-\d{2}\r?\n(?s)(.*?)(?=\r?\n## |$)/)
    def latestSection = matcher ? matcher[0][1].trim() : ""

    // Map section titles to emojis
    def emojiMap = [
            "Added"     : "âœ¨",
            "Changed"   : "ðŸ”§",
            "Deprecated": "ðŸ“‰",
            "Removed"   : "ðŸ—‘ï¸",
            "Fixed"     : "ðŸž",
            "Security"  : "ðŸ”’"
    ]

    def changelogFields = []
    def sectionRegex = ~/### (.*?)\r?\n(?s)(.*?)(?=\r?\n### |$)/

    (latestSection =~ sectionRegex).each { sec ->
        def title = sec[1].trim()
        def body = sec[2].trim()
        def emoji = emojiMap.get(title, "ðŸ“Œ")
        def formattedBody = body.readLines()
                .collect { it.replaceFirst(/^- /, "â€¢ ") }
                .join("\n")
        changelogFields << [title: "$emoji $title".trim(), body: formattedBody]
    }

    return changelogFields
}

sendDiscordWebhook {
    def modUrl = "https://raw.githubusercontent.com/Fuzss/modresources/main/mods/${project.modId}.json"
    def json
    try {
        def jsonText = new URL(modUrl).text
        json = new groovy.json.JsonSlurper().parseText(jsonText)
    } catch (Exception exception) {
        println "Discord Webhook: ${exception}"
        return
    }

    channel = project.findProperty("discordWebhookChannelId") ?: ""
    token = project.findProperty("discordWebhookToken") ?: ""
    def epochSeconds = System.currentTimeMillis() / 1000 as long
    content = "<@&875862844829208626> <t:${epochSeconds}:R>"
//    debug = true

    embed {
        title = "[${libs.versions.minecraft.get()}] ${project.modName} v${project.modVersion}"
        description = project.modDescription
        url = "https://www.curseforge.com/minecraft/mc-mods/${json.distributions.curseforge?.slug}"
        timestamp = Instant.now().toString()
        color = 5814783
        addFooter([project.modName, "v${project.modVersion}", libs.versions.minecraft.get()])
        addImage("https://raw.githubusercontent.com/Fuzss/modresources/main/pages/data/${project.modId}/banner.png")
        addThumbnail("https://raw.githubusercontent.com/Fuzss/modresources/main/pages/data/${project.modId}/logo.png")
        author = [
                name    : "Fuzs",
                url     : "https://www.curseforge.com/members/fuzs",
                icon_url: "https://raw.githubusercontent.com/Fuzss/modresources/main/pages/commons/avatar.png"
        ]

        def changelogFields = parseChangelogFields()
        changelogFields.each { addField(it.title, it.body) }
        addField("\uD83D\uDCE5 Downloads", "<:CurseForge:893088361634471948> [CurseForge](https://www.curseforge.com/minecraft/mc-mods/${json.distributions.curseforge?.slug})\n<:modrinth:1176378033578459206> [Modrinth](https://modrinth.com/mod/${json.distributions.modrinth?.slug})", true)
        addField("<:github:1422695832951455814> GitHub", "\uD83D\uDC68\u200D\uD83D\uDCBB [Source](https://github.com/Fuzss/${json.distributions.github?.slug})\n\u26A0\uFE0F [Issues](https://github.com/Fuzss/${json.distributions.github?.slug}/issues)", true)
        addField("\uD83D\uDCAC Support", "<:Fuzs:993195872131235881> <#917550806922846299>", true)
    }
}
